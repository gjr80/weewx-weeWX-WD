#!/usr/bin/python
#
# This program is free software; you can redistribute it and/or modify it under
# the terms of the GNU General Public License as published by the Free Software
# Foundation; either version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful, but WITHOUT
# ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS
# FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more
# details.
#
# Version: 1.0.3                                    Date: 31 March 2017
#
# Revision History
#   31 March 2017       v1.0.3
#       - no change, version number change only
#   14 December 2016    v1.0.2
#       - no change, version number change only
#   30 November 2016    v1.0.1
#       - initial implementation, database management functions taken from
#         weewxwd3.py
#       - fix numerous issues with old version embedded in weewxwd3.py
#
"""Configure the database used by weewx-WD"""
import optparse
import os.path
import sys
import syslog
import time

from datetime import date, timedelta

# Find the install bin subdirectory:
# I am in bin/user so get my directory
this_file = os.path.join(os.getcwd(), __file__)
this_dir = os.path.abspath(os.path.dirname(this_file))
# bin must be the next level up
(bin_dir, _tail) = os.path.split(this_dir)
# Now that we've found the bin subdirectory, inject it into the path:
sys.path.insert(0, bin_dir)

# Now we can import some weewx modules
import user.wdSearchX3
import user.weewxwd3
import user.wdAstroSearchX3
import user.wdTaggedStats3
import user.imageStackedWindRose3
import weedb
import weecfg
import weewx
import weewx.manager
import weewx.wxformulas

from weewx.units import ValueTuple
from weeutil.weeutil import timestamp_to_string

WD_DATABASE_VERSION = '1.0.3'

schema = [('dateTime',             'INTEGER NOT NULL UNIQUE PRIMARY KEY'),
          ('usUnits',              'INTEGER NOT NULL'),
          ('interval',             'INTEGER NOT NULL'),
          ('humidex',              'REAL'),
          ('appTemp',              'REAL'),
          ('outTempDay',           'REAL'),
          ('outTempNight',         'REAL')]

def logmsg(level, src, msg):
    syslog.syslog(level, '%s %s' % (src, msg))

def logdbg(src, msg):
    logmsg(syslog.LOG_DEBUG, src, msg)

def logdbg2(src, msg):
    if weewx.debug >= 2:
        logmsg(syslog.LOG_DEBUG, src, msg)

def loginf(src, msg):
    logmsg(syslog.LOG_INFO, src, msg)

def logerr(src, msg):
    logmsg(syslog.LOG_ERR, src, msg)

usage = """wd_database --help
       wd_database --create-archive
            [CONFIG_FILE|--config=CONFIG_FILE]
            [--binding=BINDING_NAME]
       wd_database --status
            [CONFIG_FILE|--config=CONFIG_FILE]
            [--binding=BINDING_NAME]
       wd_database --drop-daily
            [CONFIG_FILE|--config=CONFIG_FILE]
            [--binding=BINDING_NAME]
       wd_database --backfill-daily
            [CONFIG_FILE|--config=CONFIG_FILE]
            [--binding=BINDING_NAME]
            [--trans-days=DAYS]
       wd_database --copy-v2-data
            [CONFIG_FILE|--config=CONFIG_FILE]
            [--binding=BINDING_NAME]
            [--tranche=INTEGER]
       wd_database --clear-v2-data
            [CONFIG_FILE|--config=CONFIG_FILE]
            [--binding=BINDING_NAME]
       wd_database --string-check
            [CONFIG_FILE|--config=CONFIG_FILE]
            [--binding=BINDING_NAME] [--fix]
       wd_database --version

Description:

Configure the weewx-WD database. Most of these functions are handled
automatically by weewx-WD, but they may be useful in special cases.

Actions:

--create-archive  Create the weewx-WD database.
--status          Display weewx-WD archive status.
--drop-daily      Drop the weewx-WD daily summaries from the database.
--backfill-daily  Rebuild the weewx-WD daily summaries from the weewx-WD archive.
--copy-v2-data    Copy legacy weewx-WD observation data from the weewx archive to
                  the weewx-WD archive.
--clear-v2-data   Clear legacy weewx-WD data from the weewx (not weewx-WD) archive.
                  NOTE: This option will irreversibly clear all data stored in
                  the 'extraTemp1' and 'extraTemp2' fields in the weewx (not
                  weewx-WD) archive.
--string-check    Scan the weewx-WD archive, looking for null strings that may
                  have been introduced by a SQL editing program.
--version         Display the weewx-WD executable file versions."""

epilog = """If you are using a MySQL database it is assumed that you have the
appropriate permissions for the requested operation."""

def main():

    syslog.openlog('wd_database', syslog.LOG_PID | syslog.LOG_CONS)
    parser = optparse.OptionParser(usage=usage)
    parser.add_option('--config', dest='cfgfn', type=str, metavar="CONFIG_PATH",
                      help="Use configuration file CONFIG_PATH. Default is"
                      " /etc/weewx/weewx.conf or /home/weewx/weewx.conf.")
    parser.add_option('--version', dest='version', action='store_true',
                      help='Display weewx-WD executable file versions.')
    parser.add_option('--debug', dest='debug', action='store_true',
                      help='Display limited diagnostic information while running.')
    parser.add_option("--create-archive", dest="create_archive", action='store_true',
                      help="Create the weewx-WD database.")
    parser.add_option('--status', dest='status', action='store_true',
                      help='Display weewx-WD archive status.')
    parser.add_option("--copy-v2-data", dest="copy_v2", action='store_true',
                      help="Copy legacy weewx-WD observation data from weewx"
                      " archive to weewx-WD archive.")
    parser.add_option("--tranche", dest="tranche", default=1000,
                      help="Number of records to save to weewx-WD database in a"
                      " single transaction. Default value is 1000. May be increased"
                      " for a slight speed increase or reduced to reduce memory"
                      " usage.")
    parser.add_option("--clear-v2-data", dest="clear_v2", action='store_true',
                      help="Clear legacy weewx-WD data from weewx (not weewx-WD)"
                      " archive. NOTE: This option will irreversibly clear all"
                      " data stored in the 'extraTemp1' and 'extraTemp2' fields"
                      " in the weewx (not weewx-WD) archive.")
    parser.add_option("--drop-daily", dest="drop_daily", action='store_true',
                      help="Drop the weewx-WD daily summary tables.")
    parser.add_option('--backfill-daily', dest='backfill', action='store_true',
                      help="Backfill weewx-WD daily summary tables from weewx-WD"
                      " archive.")
    parser.add_option("--string-check", dest="string_check",
                      action="store_true",
                      help="Check a SQLite version of the weewx-WD database to"
                      " see whether it contains embedded strings.")
    parser.add_option("--fix", dest="fix", action="store_true",
                      help="Fix any embedded strings in a SQLite database.")
    parser.add_option("--binding", dest="binding", metavar="BINDING_NAME",
                      default='wd_binding',
                      help="The data binding. Default is 'wd_binding'.")
    (options, args) = parser.parse_args()

    # display file version info
    if options.version:
        print "wd_database version:                         %s" % WD_DATABASE_VERSION
        print "weewx-WD version:                            %s" % user.weewxwd3.WEEWXWD_VERSION
        print "weewx-WD SLE version:                        %s" % user.wdSearchX3.WEEWXWD_SLE_VERSION
        print "weewx-WD Astronomical SLE version:           %s" % user.wdAstroSearchX3.WEEWXWD_ASTRO_SLE_VERSION
        print "weewx-WD Tagged Statistics version:          %s" % user.wdTaggedStats3.WEEWXWD_TAGGED_STATS_VERSION
        print "weewx-WD Stacked Windrose Generator version: %s" % user.imageStackedWindRose3.WEEWXWD_STACKED_WINDROSE_VERSION
        sys.exit()

    config_fn, config_dict = weecfg.read_config(options.cfgfn, args)
    print "Using configuration file %s." % config_fn

    # get our bindings and advise the user what we are using
    db_binding_wd, db_binding_wx = get_bindings(config_dict)
    database_wx = config_dict['DataBindings'][db_binding_wx]['database']
    database_wd = config_dict['DataBindings'][db_binding_wd]['database']
    print "Using weewx database binding '%s', which is bound to database '%s'" % (db_binding_wx, database_wx)
    print "Using weewx-WD database binding '%s', which is bound to database '%s'" % (db_binding_wd, database_wd)

    # create weewx-WD db
    if options.create_archive:
        createWeewxWDDatabase(config_dict, db_binding_wd)
        sys.exit()

    # display weewx-WD status
    if options.status:
        print_status(config_dict, db_binding_wd, db_binding_wx)
        sys.exit()

    # copy legacy weewx-WD data from weewx db
    if options.copy_v2:
        # just in case we were given a nonsense value
        try:
            _tranche = int(options.tranche)
            # avoid 0
            _tranche = _tranche if _tranche > 0 else 1000
        except:
            _tranche = 1000
        copy_v2_data(config_dict, db_binding_wd, db_binding_wx, _tranche)
        sys.exit()

    # clear legacy weewx-WD data from weewx db
    if options.clear_v2:
        clear_v2_data(config_dict, db_binding_wx)
        sys.exit()

    # drop the weewx-WD db daily summary tables
    if options.drop_daily:
        dropDaily(config_dict, db_binding_wd)
        sys.exit()

    # backfill the weewx-WD db daily summary tables
    if options.backfill:
        backfillDaily(config_dict, db_binding_wd)
        sys.exit()

    # check the weewx-WD db for strings
    if options.string_check:
        string_check(config_dict, db_binding_wd, options.fix)
        sys.exit()

    # if we got this far we must have had no actions specified no display our
    # help and exit
    parser.print_help()

def createWeewxWDDatabase(config_dict, db_binding_wd):
    """Create a weewx-WD database."""

    # Try a simple open. If it succeeds, that means the database
    # exists and is initialized. Otherwise, an exception will be thrown.
    _msg = "Creating weewx-WD database."
    loginf("createWeewxWDDatabase:", _msg)
    print _msg
    try:
        with weewx.manager.open_manager_with_config(config_dict, db_binding_wd) as dbmanager:
            _msg = "Database '%s' already exists. Nothing done." % (dbmanager.database_name,)
    except weedb.OperationalError:
        # Database does not exist. Try again, but allow initialization:
        with weewx.manager.open_manager_with_config(config_dict, db_binding_wd, initialize=True) as dbmanager:
            _msg = "Created database '%s'" % (dbmanager.database_name,)
    loginf("createWeewxWDDatabase:", _msg)
    print _msg

def print_status(config_dict, db_binding_wd, db_binding_wx):
    """ Display brief status info on need to reconstruct weewx-WD archive data.

        The installation of the weewx-WD extension does not in itself
        reconstruct any earlier weewx-WD data that was previously kept in the
        weewx archive. A simple check is conducted of the earliest and latest
        timestamps in the weewx-WD archive that hold weewx-WD data. These times
        are compared against the earliest and latest timestamps in the weewx
        archive.

        Parameters:
            config_dict:   a dictionary of the weewx.conf settings
            db_binding_wd: binding for weewx-WD database
            db_binding_wx: binding for weewx database

        Returns:
            Nothing.
    """

    manager_dict = weewx.manager.get_manager_dict(config_dict['DataBindings'],
                                                  config_dict['Databases'],
                                                  db_binding_wd)
    database_name = manager_dict['database_dict']['database_name']
    with weewx.manager.open_manager_with_config(config_dict, db_binding_wd) as dbmanager_wd:
        with weewx.manager.open_manager_with_config(config_dict, db_binding_wx) as dbmanager_wx:
            # initialise some variables
            earliest_wd_ts = None
            latest_wd_ts = None
            table_name = dbmanager_wd.table_name

            # find earliest and latest weewx-WD archive timestamps that hold valid data
            _row = dbmanager_wd.getSql("SELECT MIN(dateTime), MAX(dateTime) FROM %s WHERE humidex IS NOT NULL AND appTemp IS NOT NULL" % table_name)
            if _row:
                # we have an answer
                earliest_wd_ts = _row[0]
                latest_wd_ts = _row[1]

            # get our first and last good timestamps from weewx archive
            earliest_wx_ts = dbmanager_wx.firstGoodStamp()
            latest_wx_ts = dbmanager_wx.lastGoodStamp()

            if earliest_wd_ts is None or latest_wd_ts is None:
                # no weewx-WD data, reconstruct the lot if available
                if earliest_wx_ts is not None and latest_wx_ts is not None:
                    # data available so say so
                    print "Reconstruction of weewx-WD database '%s' table '%s' data" % (database_name,
                                                                                        table_name)
                    print "from %s to %s" % (timestamp_to_string(earliest_wx_ts),
                                             timestamp_to_string(latest_wx_ts))
                    print "(up to approx %d days) is recommended." % (int((latest_wx_ts-earliest_wx_ts)/86400)+1, )
                else:
                    # no data with which to reconstruct
                    print "Reconstruction of weewx-WD database '%s' table '%s' is not required" % (database_name, table_name)
            elif earliest_wx_ts is not None and latest_wx_ts is not None:
                # some weewx-WD data available and we also have some weewx data
                # check if we need to reconstruct
                if earliest_wd_ts > earliest_wx_ts:
                    # we have 'before' data to reconstruct
                    print "Reconstruction of weewx-WD database '%s' table '%s' data" % (database_name,
                                                                                        table_name)
                    print "from %s to %s" % (timestamp_to_string(earliest_wx_ts),
                                             timestamp_to_string(earliest_wd_ts))
                    print "(up to approx %d days) is recommended." % (int((earliest_wd_ts-earliest_wx_ts)/86400)+1, )
                elif latest_wd_ts < latest_wx_ts:
                    # we have 'after' data to reconstruct
                    print "Reconstruction of weewx-WD database '%s' table '%s' data" % (database_name,
                                                                                        table_name)
                    print "from %s to %s" % (timestamp_to_string(latest_wd_ts),
                                             timestamp_to_string(latest_wx_ts))
                    print "(up to approx %d days) is recommended." % (int((latest_wx_ts-latest_wd_ts)/86400)+1, )
                else:
                    # no data with which to reconstruct so say so
                    print "Reconstruction of weewx-WD database '%s' table '%s' is not required" % (database_name,
                                                                                                   table_name)
            else:
                # no data with which to reconstruct so say so
                print "Reconstruction of weewx-WD database '%s' table '%s' is not required" % (database_name,
                                                                                               table_name)

def copy_v2_data(config_dict, db_binding_wd, db_binding_wx, tranche):
    """ Copy legacy weewx-WD data from a weewx archive.

        Does a simple check of the first and last valid timestamps in weewx-WD
        and weewx archives to identify any weewx-WD missing data timespans.
        The check is simple and only identifies missing data before the first
        and after the last valid weewx-WD timestamps. Missing data between
        these timestamps will not be identified and copied.

        Parameters:
            config_dict: a dictionary of the weewx.conf settings
            db_binding_wd: binding for weewx-WD database
            db_binding_wx: binding for weewx database

        Returns:
            Nothing.
    """

    t1 = time.time()

    with weewx.manager.open_manager_with_config(config_dict, db_binding_wd) as dbmanager_wd:
        with weewx.manager.open_manager_with_config(config_dict, db_binding_wx) as dbmanager_wx:
            loginf("copy_v2_data:", "Copying legacy weewx-WD data...")
            print "Copying legacy weewx-WD data..."
            # get the spans of any records we need to insert both:
            # - before the start of our weewx-WD database, and
            # - after the end of our weewx-WD database
            before_span, after_span = get_backfill_spans(dbmanager_wd,
                                                         dbmanager_wx)
            before_start_ts, before_stop_ts, after_start_ts, after_stop_ts = before_span + after_span

            # do the backfill noting numbers of records, days and periods we
            # have dealt with
            nrecs_b = None
            ndays_b = 0
            nrecs_a = None
            ndays_a = 0
            nperiods = 0
            if before_start_ts is not None and before_stop_ts is not None:
                nrecs_b, ndays_b = backfill_wd(dbmanager_wd,
                                               dbmanager_wx,
                                               before_start_ts-1,
                                               before_stop_ts-1,
                                               tranche)
                if nrecs_b is not None:
                    nperiods += 1 if nrecs_b > 0 else nperiods
            if after_start_ts is not None and after_stop_ts is not None:
                nrecs_a, ndays_a = backfill_wd(dbmanager_wd,
                                               dbmanager_wx,
                                               after_start_ts,
                                               after_stop_ts,
                                               tranche)
                if nrecs_a is not None:
                    nperiods += 1 if nrecs_a > 0 else nperiods

            tdiff = time.time() - t1
            # informational statement on what we did/did not do
            nrecs = sum(filter(None, (nrecs_b, nrecs_a)))
            if nperiods > 0:
                _msg = "%d record(s) over %d period(s) covering approximately %d day(s) processed in %s." % (nrecs,
                                                                                                             nperiods,
                                                                                                             ndays_b + ndays_a,
                                                                                                             str(timedelta(seconds=int(tdiff))))
            else:
                _msg = "No legacy data found or action cancelled by user, no weewx-WD data backfilled."
            loginf("copy_v2_data:", _msg)
            print _msg

def dropDaily(config_dict, db_binding_wd):
    """ Drops the weewx-WD daily summaries.

        Parameters:
            config_dict:   a dictionary of the weewx.conf settings
            db_binding_wd: binding for weewx-WD database

        Returns:
            Nothing.
    """

    # get our db name
    manager_dict = weewx.manager.get_manager_dict(config_dict['DataBindings'],
                                                  config_dict['Databases'],
                                                  db_binding_wd)
    database_name = manager_dict['database_dict']['database_name']

    ans = None
    # check with the user if we want to do this
    while ans not in ['y', 'n']:
        print "Proceeding will delete all your daily summaries from database '%s'" % (database_name,)
        ans = raw_input("Are you sure you want to proceed (y/n)? ")
        if ans == 'y':
            # yes we are going to drop the dail ysummaries
            # log it and tell the user
            loginf("dropDaily:", "Dropping daily summary tables from database '%s' ... " % (database_name,))
            print "Dropping daily summary tables from database '%s' ... " % (database_name,)
            # get a manager for the weewx-WD db but be prepared to catch any
            # exceptions
            try:
                with weewx.manager.open_manager_with_config(config_dict, db_binding_wd) as dbmanager_wd:
                    # drop the daily summaries but be prepared to catch any
                    # exceptions
                    try:
                        dbmanager_wd.drop_daily()
                    except weedb.OperationalError, e:
                        # we received an error
                        loginf("dropDaily:", "Received error '%s'" % e)
                        print "Received error '%s'\nPerhaps there was no daily summary?" % e
                    else:
                        # compelted successfully so log it and tell the user
                        loginf("dropDaily:", "Dropped daily summary tables from database '%s'" % (database_name,))
                        print "Dropped daily summary tables from database '%s'" % (database_name,)
            except weedb.OperationalError:
                # No daily summaries. Nothing to be done.
                loginf("dropDaily:", "No daily summaries found in database '%s'. Nothing done." % (database_name,))
                print "No daily summaries found in database '%s'. Nothing done." % (database_name,)
        elif ans == 'n':
            # user cancelled it so say so and return
            print "Action cancelled. Nothing done."

def backfillDaily(config_dict, db_binding_wd):
    """ Backfill weewx-WD daily summaries.

        Parameters:
            config_dict: a dictionary of the weewx.conf settings
            db_binding_wd: binding for weewx-WD database

        Returns:
            Nothing.
    """

    # get our db name
    manager_dict = weewx.manager.get_manager_dict(config_dict['DataBindings'],
                                                  config_dict['Databases'],
                                                  db_binding_wd)
    database_name = manager_dict['database_dict']['database_name']

    t1 = time.time()
    loginf("backfillDaily:", "Backfilling daily summary tables in database '%s' ... " % (database_name,))
    print "Backfilling daily summary tables in database '%s' ... " % (database_name,)
    # Open up the archive. This will create the tables necessary for the daily
    # summaries if they don't already exist.
    with weewx.manager.open_manager_with_config(config_dict,db_binding_wd,initialize=True) as dbmanager_wd:
        # now backfill the tables
        nrecs, ndays = dbmanager_wd.backfill_day_summary()
    tdiff = time.time() - t1
    # tell the user what happened
    if nrecs:
        _msg = "Backfilled '%s' with %d records over %d days in %.2f seconds" % (database_name,
                                                                                 nrecs,
                                                                                 ndays,
                                                                                 tdiff)
    else:
        _msg = "Daily summaries up to date in database '%s'." % database_name
    loginf("backfillDaily:", _msg)
    print _msg

def clear_v2_data(config_dict, db_binding_wx):
    """ Clear any legacy data from the weewx (not weewx-WD) database.

        Under weewx v2.x weewx-WD stored humidex and apparent temperature data
        in the weewx archive in fields extraTemp1 and extratemp2 respectively.
        Under weewx v3 weewx-WD now stores this data in a separate database and
        hence this legacy data can be removed from the weewx database.

        Parameters:
            config_dict:   a dictionary of the weewx.conf settings
            db_binding_wx: binding for weewx database

        Returns:
            Nothing.
    """

    # get our db name
    manager_dict = weewx.manager.get_manager_dict(config_dict['DataBindings'],
                                                  config_dict['Databases'],
                                                  db_binding_wx)
    database_name = manager_dict['database_dict']['database_name']
    # get a manager for the weewx archive
    with weewx.manager.open_manager_with_config(config_dict, db_binding_wx) as dbmanager_wx:
        # get our first and last good timestamps
        start_ts = dbmanager_wx.firstGoodStamp()
        stop_ts = dbmanager_wx.lastGoodStamp()
        # do we actually have any legacy data (extraTemp1 and extraTemp2 fields
        # with data in them) to remove?
        _row = dbmanager_wx.getSql("SELECT COUNT(extraTemp1), COUNT(extraTemp2) FROM %s" % dbmanager_wx.table_name)
        if _row:
            # we have an answer
            if _row[0] > 0 or _row[1] > 0:
                # we do have some fields to clear so clear them
                # set some counters
                nrecs = 0
                ndays = (date.fromtimestamp(stop_ts) -  date.fromtimestamp(start_ts)).days
                # confirm we still want to do this
                print "'extraTemp1' and 'extraTemp2' data in database '%s' from" % (database_name, )
                print "     %s to %s (approx %d days) is about to be cleared." % (timestamp_to_string(start_ts),
                                                                                  timestamp_to_string(stop_ts),
                                                                                  ndays)
                print "     Any data in these fields will be irretrievably lost."
                ans = None
                ans = raw_input("Are you sure you wish to proceed (y/n)? ")
                if ans == 'y':
                    # we do so go ahead and clear them
                    for _rec in dbmanager_wx.genBatchRecords(start_ts - 1, stop_ts):
                        # clear the extraTemp1 and extraTemp2 fields
                        dbmanager_wx.updateValue(_rec['dateTime'],
                                                 'extraTemp1',
                                                 None)
                        dbmanager_wx.updateValue(_rec['dateTime'],
                                                 'extraTemp2',
                                                 None)
                        nrecs += 1
                    # all done, say so and give some stats
                    print "Done. 'extraTemp1' and 'extraTemp2' cleared in %d records (approx %d days)." %(nrecs,
                                                                                                          ndays)
                elif ans == 'n':
                    # we backed out so say so
                    print "Action cancelled. Nothing done."
            else:
                # no rows need to be cleared
                print "No 'extraTemp1' or 'extraTemp2' data found in database '%s' that need to be cleared. No data changed." % (database_name,)
        else:
            # no rows need to be cleared
            print "No 'extraTemp1' or 'extraTemp2' data found in database '%s' that need to be cleared. No data changed." % (database_name,)

def string_check(config_dict, db_binding, fix=False):
    """Check the weewx-WD db for null strings."""

    _found_one = None
    # Open up the main database archive
    with weewx.manager.open_manager_with_config(config_dict, db_binding) as dbmanager:
        print "Checking database '%s' for strings..." % dbmanager.database_name
        obs_pytype_list = []
        obs_list = []

        # Get the schema and extract the Python type each observation type should be
        for column in dbmanager.connection.genSchemaOf('archive'):
            schema_type = column[2]
            if schema_type == 'INTEGER':
                schema_type = int
            elif schema_type == 'REAL':
                schema_type = float
            elif schema_type == 'STR':
                schema_type = str
            # Save the observation type for this column (eg, 'outTemp'):
            obs_list.append(column[1])
            # Save the Python type for this column (eg, 'int'):
            obs_pytype_list.append(schema_type)

        # Cycle through each row in the database
        for record in dbmanager.genBatchRows():
            # Now examine each column
            for icol in range(len(record)):
                # Check to see if this column is an instance of the correct Python type
                if record[icol] is not None and not isinstance(record[icol], obs_pytype_list[icol]):
                    # Oops. Found a bad one. Print it out
                    sys.stdout.write("Timestamp = %s; record['%s']= %r; ... " % (record[0], obs_list[icol], record[icol]))
                    _found_one = True
                    if fix:
                        # Cooerce to the correct type. If it can't be done, then set it to None
                        try:
                            corrected_value = obs_pytype_list[icol](record[icol])
                        except ValueError:
                            corrected_value = None
                        # Update the database with the new value
                        dbmanager.updateValue(record[0], obs_list[icol], corrected_value)
                        # Inform the user
                        sys.stdout.write("changed to %r\n" % corrected_value)
                    else:
                        sys.stdout.write("ignored.\n")
        if _found_one is None:
            print "Check complete. No null strings found in database '%s'" % dbmanager.database_name

def backfill_wd(dbmanager_wd, dbmanager_wx, start_ts, stop_ts, tranche_length):
    """ Backfill weewx-WD database with derived obs over a timespan.

        Steps through each weewx record in the timespan extracting
        humidex/appTemp from extraTemp1/extraTemp2 values if they contain data
        otherwise humidex/appTemp are calculated and saved in the weewx-WD
        database against the original timestamp. Also sets outTempDay and
        outTempNight such that:
        - outTempDay=outTemp if time is > 06:00 and time is <= 18:00
        - outTempNight=outTemp if time is <= 06:00 and time is > 18:00
        - outTempDay and outTempNight = None at all other times.

        Parameters:
            dbmanager_wd: manager object for weewx-WD database
            dbmanager_wx: manager object for weewx database
            start_ts:     inclusive timestamp for the start of the timespan
            stop_ts:      inclusive timestamp for the end of the timespan

        Returns:
            ndays: the number of days processed
    """

    # set up a reference time point
    t1 = time.time()

    # set some stats
    nrecs = None

    ndays = (date.fromtimestamp(stop_ts) -  date.fromtimestamp(start_ts)).days

    # how many recs do we need to update?
    _row = dbmanager_wx.getSql("SELECT COUNT(dateTime) FROM %s WHERE dateTime >= %s AND dateTime <= %s" % (dbmanager_wx.table_name, start_ts, stop_ts))
    if _row:
        # we have an answer
        nrecs = _row[0] if _row[0] > 0 else None

    # confirm we still want to do this
    _msg = "%d records have been identified to backfill database '%s' from" % (nrecs,
                                                                               dbmanager_wd.database_name)
    loginf("backfill_wd:", _msg)
    _msg = "     %s to %s (approx %d days)." % (timestamp_to_string(start_ts),
                                                timestamp_to_string(stop_ts),
                                                ndays)
    loginf("backfill_wd:", _msg)
    print "%d records have been identified to backfill database '%s' from" % (nrecs, dbmanager_wd.database_name)
    print "     %s to %s (approx %d days)." % (timestamp_to_string(start_ts), timestamp_to_string(stop_ts), ndays)
    print "     This may take some time (hours) to complete."
    ans = None
    # do we wnat to do this?
    ans = raw_input("Are you sure you wish to proceed (y/n)? ")
    if ans == 'y':
        # yes, so log it and tell the user
        loginf("backfill_wd:", "Processing %d records..." % (nrecs,))
        print "Processing %d records..." % (nrecs,)
        # create a generator object that will yield records over our timespan that have had humidex/appTemp added
        # need to be inclusive on the start hence the - 1
        records = WdGenerateDerived(dbmanager_wx.genBatchRecords(start_ts-1,
                                                                 stop_ts))
        nrecs = 0
        _tranche = []
        # step through each record and add it to our tranche
        for _rec in records:
            _tranche.append(_rec)
            nrecs += 1
            # if the tranche is full then add the records in a transaction
            if len(_tranche) >= tranche_length:
                # add the records
                dbmanager_wd.addRecord(_tranche)
                # update our progress
                _msg = "Records processed: %d; Last timestamp: %s\r" % (nrecs,
                                                                        timestamp_to_string(_rec['dateTime']))
                print >> sys.stdout, _msg,
                sys.stdout.flush()
                _tranche = []
        # we have finished but to we have any records sitting in the tranche
        # that have not been written to db?
        if len(_tranche) > 0:
            # yes, add the records
            dbmanager_wd.addRecord(_tranche)
            # update our progress
            _msg = "Records processed: %d; Last timestamp: %s\r" % (nrecs,
                                                                    timestamp_to_string(_rec['dateTime']))
            print >> sys.stdout, _msg,
        print
        sys.stdout.flush()
    else:
        # we backed out so log/tell the user and set nrecs to None
        loginf("backfill_wd:", "Action cancelled. Nothing done.")
        print "Action cancelled. Nothing done."
        nrecs = None

    # return a sumamry of our results
    return nrecs, ndays

def get_backfill_spans(dbmanager_wd, dbmanager_wx):
    """ Calculate timespans that require backfill of data from weewx
        archive to weewx-WD archive.

        If weewx-WD was installed some time after weewx was first run there
        will likely be one or more periods of missing data in the weewx-WD
        archive that is otherwise available from the weewx archive. This
        routine takes a simplistic approach to determining these timespans as
        follows:
        - first good timestamp in weewx archive to first good timestamp in
          weewx-WD archive
        - last good timestamp in weewx-WD archive to last good timestamp in
          weewx archive
        - if there is no data in the weewx-WD archive then first good timestamp
          to last good timestamp in weewx archive
        - if there is no data in the weewx archive then a (None, None) timespan
          is returned for each period

        Gaps in the weewx-WD data are not included in any timespand results.

        Parameters:
            dbmanager_wd: Manager object for weewx-WD database.
            dbmanager_wx: Manager object for weewx database.

        Returns:
            A tuple consisting of two tuples each consisting of a start and
            stop timestamp. The first tuple represents the timespan of data
            that is older then the weewx-WD data. The second tuple represents
            the timespan of data that is newer than the weewx-WD data.
            (None, None) represents no timespan.
    """

    # get fist and last good timestamps for each database
    first_wd_ts = dbmanager_wd.firstGoodStamp()
    last_wd_ts = dbmanager_wd.lastGoodStamp()
    first_wx_ts = dbmanager_wx.firstGoodStamp()
    last_wx_ts = dbmanager_wx.lastGoodStamp()

    if first_wd_ts is None or last_wd_ts is None:
        # no data in wd
        if first_wx_ts is not None and last_wx_ts is not None:
            # we have data in wx
            return ((first_wx_ts, last_wx_ts), (None, None))
        else:
            # we have no data in wx
            return ((None, None), (None, None))
    else:
        # wd data
        if first_wx_ts is not None and last_wx_ts is not None:
            # we have data in wx
            if first_wx_ts < first_wd_ts:
                #we have 'before' data to add
                before = (first_wx_ts, first_wd_ts)
            else:
                before = (None, None)
            if last_wx_ts > last_wd_ts:
                #we have 'after' data to add
                after = (last_wd_ts, last_wx_ts)
            else:
                after = (None, None)
            return (before, after)
        else:
            # we have no data in wx
            return ((None, None), (None, None))

def get_bindings(config_dict):
    """ Get db_bindings for the weewx-WD and weewx databases.

        Parameters:
            config_dict: a dictionary of the weewx.conf settings

        Returns:
            db_binding_wd: binding for weewx-WD database.
            db_binding_wx: binding for weewx database.
    """

    # Extract our binding from the weewx-WD section of the config file. If
    # it's missing, fill with a default
    if 'WeewxWD' in config_dict:
        db_binding_wd = config_dict['WeewxWD'].get('data_binding', 'wd_binding')
    else:
        db_binding_wd = 'wd_binding'

    # Extract the weewx binding for use when we check the need for backfill
    # from the weewx archive
    if 'StdArchive' in config_dict:
        db_binding_wx = config_dict['StdArchive'].get('data_binding',
                                                      'wx_binding')
    else:
        db_binding_wx = 'wx_binding'

    return (db_binding_wd, db_binding_wx)

#=============================================================================
#                          Class WdGenerateDerived
#=============================================================================

class WdGenerateDerived(object):
    """Wrapper to add weewx-WD derived obs to the wrapped generator."""

    def __init__(self, input_generator):
        """ Initialize an instance of WdGenerateDerived

            input_generator: An iterator which will return dictionary records.
        """
        self.input_generator = input_generator
        self.mask = ['usUnits', 'outTemp', 'windSpeed', 'outHumidity']

    def __iter__(self):
        return self

    def next(self):
        # get our next record
        _rec = self.input_generator.next()

        # get our historical humidex, if not available then calculate it
        if _rec['extraTemp1'] is not None:
            _rec['humidex'] = _rec['extraTemp1']
        else:
            # humidex is not available so calculate it
            # first get our unit system
            _units = _rec['usUnits']
            # strip out those obs we will need to calc humidex
            _mini_rec = {_key: _rec[_key] for _key in self.mask}
            # convert the mini record
            _mini_rec_wx = weewx.units.to_METRICWX(_mini_rec)
            # calculate humidex
            _mini_rec_wx['humidex'] = weewx.wxformulas.humidexC(_mini_rec_wx['outTemp'],
                                                                _mini_rec_wx['outHumidity'])
            # convert our mini record back to the original units
            _mini_rec = weewx.units.to_std_system(_mini_rec_wx, _units)
            # add humidex to our original record
            _rec['humidex'] = _mini_rec['humidex']

        # get our historical appTemp, if not available then calculate it
        if _rec['extraTemp2'] is not None:
            _rec['appTemp'] = _rec['extraTemp2']
        else:
            # appTemp is not available so calculate it
            # first get our unit system
            _mini_rec = {_key: _rec[_key] for _key in self.mask}
            _units = _mini_rec['usUnits']
            # convert the mini record
            _mini_rec_wx = weewx.units.to_METRICWX(_mini_rec)
            # calculate apptemp
            _mini_rec_wx['appTemp'] = weewx.wxformulas.apptempC(_mini_rec_wx['outTemp'],
                                                                _mini_rec_wx['outHumidity'],
                                                                _mini_rec_wx['windSpeed'])
            # convert our mini record back to the original units
            _mini_rec = weewx.units.to_std_system(_mini_rec_wx, _units)
            # add appTemp to our original record
            _rec['appTemp'] = _mini_rec['appTemp']

        # 'calculate' outTempNight, units play no role in the calc so just get
        # the result and add it to our record
        _rec['outTempDay'], _rec['outTempNight'] = user.weewxwd3.calc_daynighttemps(_rec)

        # return our modified record
        return _rec

if __name__ == '__main__':
    main()
